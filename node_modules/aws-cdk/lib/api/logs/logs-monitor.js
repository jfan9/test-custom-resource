"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudWatchLogEventMonitor = void 0;
const util = require("util");
const chalk = require("chalk");
const uuid = require("uuid");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const util_1 = require("../../util");
class CloudWatchLogEventMonitor {
    constructor(props) {
        var _a, _b;
        /**
         * Map of environment (account:region) to LogGroupsAccessSettings
         */
        this.envsLogGroupsAccessSettings = new Map();
        /**
         * After reading events from all CloudWatch log groups
         * how long should we wait to read more events.
         *
         * If there is some error with reading events (i.e. Throttle)
         * then this is also how long we wait until we try again
         */
        this.pollingInterval = 2000;
        this.startTime = (_b = (_a = props.startTime) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
        this.ioHelper = props.ioHelper;
    }
    /**
     * resume reading/printing events
     */
    async activate() {
        this.monitorId = uuid.v4();
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5032.msg('Start monitoring log groups', {
            monitor: this.monitorId,
            logGroupNames: this.logGroupNames(),
        }));
        await this.tick();
        this.scheduleNextTick();
    }
    /**
     * deactivates the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered
     * and clears the list of tracked log groups
     */
    async deactivate() {
        const oldMonitorId = this.monitorId;
        this.monitorId = undefined;
        this.startTime = Date.now();
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5034.msg('Stopped monitoring log groups', {
            monitor: oldMonitorId,
            logGroupNames: this.logGroupNames(),
        }));
        this.envsLogGroupsAccessSettings.clear();
    }
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple stacks that deploy to
     * multiple environments (account+region), we need to store a list of log groups
     * per env along with the SDK object that has access to read from
     * that environment.
     */
    addLogGroups(env, sdk, logGroupNames) {
        var _a;
        const awsEnv = `${env.account}:${env.region}`;
        const logGroupsStartTimes = logGroupNames.reduce((acc, groupName) => {
            acc[groupName] = this.startTime;
            return acc;
        }, {});
        this.envsLogGroupsAccessSettings.set(awsEnv, {
            sdk,
            logGroupsStartTimes: {
                ...(_a = this.envsLogGroupsAccessSettings.get(awsEnv)) === null || _a === void 0 ? void 0 : _a.logGroupsStartTimes,
                ...logGroupsStartTimes,
            },
        });
    }
    logGroupNames() {
        return Array.from(this.envsLogGroupsAccessSettings.values()).flatMap((settings) => Object.keys(settings.logGroupsStartTimes));
    }
    scheduleNextTick() {
        if (!this.monitorId) {
            return;
        }
        setTimeout(() => void this.tick(), this.pollingInterval);
    }
    async tick() {
        // excluding from codecoverage because this
        // doesn't always run (depends on timing)
        /* c8 ignore next */
        if (!this.monitorId) {
            return;
        }
        try {
            const events = (0, util_1.flatten)(await this.readNewEvents());
            for (const event of events) {
                await this.print(event);
            }
            // We might have been stop()ped while the network call was in progress.
            if (!this.monitorId) {
                return;
            }
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E5035.msg('Error occurred while monitoring logs: %s', { error: e }));
        }
        this.scheduleNextTick();
    }
    /**
     * Reads all new log events from a set of CloudWatch Log Groups
     * in parallel
     */
    async readNewEvents() {
        const promises = [];
        for (const settings of this.envsLogGroupsAccessSettings.values()) {
            for (const group of Object.keys(settings.logGroupsStartTimes)) {
                promises.push(this.readEventsFromLogGroup(settings, group));
            }
        }
        // Limited set of log groups
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        return Promise.all(promises);
    }
    /**
     * Print out a cloudwatch event
     */
    async print(event) {
        await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_I5033.msg(util.format('[%s] %s %s', chalk.blue(event.logGroupName), chalk.yellow(event.timestamp.toLocaleTimeString()), event.message.trim()), event));
    }
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the hotswap was triggered or
     * when the last event was read on the previous tick
     */
    async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
        var _a, _b;
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group
        const startTime = (_a = logGroupsAccessSettings.logGroupsStartTimes[logGroupName]) !== null && _a !== void 0 ? _a : this.startTime;
        let endTime = startTime;
        try {
            const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
                logGroupName: logGroupName,
                limit: 100,
                startTime: startTime,
            });
            const filteredEvents = (_b = response.events) !== null && _b !== void 0 ? _b : [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been suppressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `watch` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the CloudWatch is not created
            // until something is logged, so just keep polling until
            // there is somthing to find
            if (e.name === 'ResourceNotFoundException') {
                return [];
            }
            throw e;
        }
        logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
        return events;
    }
}
exports.CloudWatchLogEventMonitor = CloudWatchLogEventMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibG9ncy1tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBRTdCLHlGQUEyRjtBQUMzRixxQ0FBcUM7QUFvQ3JDLE1BQWEseUJBQXlCO0lBdUJwQyxZQUFZLEtBQXFDOztRQWpCakQ7O1dBRUc7UUFDYyxnQ0FBMkIsR0FBRyxJQUFJLEdBQUcsRUFBbUMsQ0FBQztRQUUxRjs7Ozs7O1dBTUc7UUFDYyxvQkFBZSxHQUFXLElBQUssQ0FBQztRQU0vQyxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQUEsTUFBQSxLQUFLLENBQUMsU0FBUywwQ0FBRSxPQUFPLEVBQUUsbUNBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzFELElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsUUFBUTtRQUNuQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUUzQixNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsNkJBQTZCLEVBQUU7WUFDakYsT0FBTyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3ZCLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFO1NBQ3BDLENBQUMsQ0FBQyxDQUFDO1FBRUosTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLFVBQVU7UUFDckIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVUsQ0FBQztRQUNyQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUU1QixNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLFlBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsK0JBQStCLEVBQUU7WUFDbkYsT0FBTyxFQUFFLFlBQVk7WUFDckIsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUU7U0FDcEMsQ0FBQyxDQUFDLENBQUM7UUFFSixJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFlBQVksQ0FBQyxHQUFzQixFQUFFLEdBQVEsRUFBRSxhQUF1Qjs7UUFDM0UsTUFBTSxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM5QyxNQUFNLG1CQUFtQixHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQzlDLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUFFO1lBQ2pCLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ2hDLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUNELEVBQXdDLENBQ3pDLENBQUM7UUFDRixJQUFJLENBQUMsMkJBQTJCLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRTtZQUMzQyxHQUFHO1lBQ0gsbUJBQW1CLEVBQUU7Z0JBQ25CLEdBQUcsTUFBQSxJQUFJLENBQUMsMkJBQTJCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQywwQ0FBRSxtQkFBbUI7Z0JBQ3BFLEdBQUcsbUJBQW1CO2FBQ3ZCO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLGFBQWE7UUFDbkIsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO0lBQ2hJLENBQUM7SUFFTyxnQkFBZ0I7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNwQixPQUFPO1FBQ1QsQ0FBQztRQUVELFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFJO1FBQ2hCLDJDQUEyQztRQUMzQyx5Q0FBeUM7UUFDekMsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDcEIsT0FBTztRQUNULENBQUM7UUFFRCxJQUFJLENBQUM7WUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFBLGNBQU8sRUFBQyxNQUFNLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1lBQ25ELEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7Z0JBQzNCLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMxQixDQUFDO1lBRUQsdUVBQXVFO1lBQ3ZFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ3BCLE9BQU87WUFDVCxDQUFDO1FBQ0gsQ0FBQztRQUFDLE9BQU8sQ0FBTSxFQUFFLENBQUM7WUFDaEIsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxZQUFFLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxFQUFFLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNqSCxDQUFDO1FBRUQsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7T0FHRztJQUNLLEtBQUssQ0FBQyxhQUFhO1FBQ3pCLE1BQU0sUUFBUSxHQUE4QyxFQUFFLENBQUM7UUFDL0QsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLENBQUMsMkJBQTJCLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUNqRSxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsQ0FBQztnQkFDOUQsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDOUQsQ0FBQztRQUNILENBQUM7UUFDRCw0QkFBNEI7UUFDNUIsd0VBQXdFO1FBQ3hFLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQ7O09BRUc7SUFDSyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQXlCO1FBQzNDLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsWUFBRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FDakQsSUFBSSxDQUFDLE1BQU0sQ0FDVCxZQUFZLEVBQ1osS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQzlCLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLEVBQ2xELEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQ3JCLEVBQ0QsS0FBSyxDQUNOLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssS0FBSyxDQUFDLHNCQUFzQixDQUNsQyx1QkFBZ0QsRUFDaEQsWUFBb0I7O1FBRXBCLE1BQU0sTUFBTSxHQUF5QixFQUFFLENBQUM7UUFFeEMsK0RBQStEO1FBQy9ELHlFQUF5RTtRQUN6RSw4REFBOEQ7UUFDOUQsTUFBTSxTQUFTLEdBQUcsTUFBQSx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsbUNBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUM5RixJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUM7UUFDeEIsSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLENBQUMsZUFBZSxDQUFDO2dCQUNsRixZQUFZLEVBQUUsWUFBWTtnQkFDMUIsS0FBSyxFQUFFLEdBQUc7Z0JBQ1YsU0FBUyxFQUFFLFNBQVM7YUFDckIsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxjQUFjLEdBQUcsTUFBQSxRQUFRLENBQUMsTUFBTSxtQ0FBSSxFQUFFLENBQUM7WUFFN0MsS0FBSyxNQUFNLEtBQUssSUFBSSxjQUFjLEVBQUUsQ0FBQztnQkFDbkMsSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUM7d0JBQ1YsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPO3dCQUN0QixZQUFZO3dCQUNaLFNBQVMsRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxFQUFFO3FCQUNwRSxDQUFDLENBQUM7b0JBRUgsSUFBSSxLQUFLLENBQUMsU0FBUyxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7d0JBQ2pELE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO29CQUM1QixDQUFDO2dCQUNILENBQUM7WUFDSCxDQUFDO1lBQ0QsZ0dBQWdHO1lBQ2hHLHFHQUFxRztZQUNyRyxtR0FBbUc7WUFDbkcsMkZBQTJGO1lBQzNGLElBQUksY0FBYyxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUN4RCxNQUFNLENBQUMsSUFBSSxDQUFDO29CQUNWLE9BQU8sRUFBRSxxRkFBcUY7b0JBQzlGLFlBQVk7b0JBQ1osU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQztpQkFDN0IsQ0FBQyxDQUFDO1lBQ0wsQ0FBQztRQUNILENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLHNEQUFzRDtZQUN0RCx3REFBd0Q7WUFDeEQsNEJBQTRCO1lBQzVCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSywyQkFBMkIsRUFBRSxDQUFDO2dCQUMzQyxPQUFPLEVBQUUsQ0FBQztZQUNaLENBQUM7WUFDRCxNQUFNLENBQUMsQ0FBQztRQUNWLENBQUM7UUFDRCx1QkFBdUIsQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZLENBQUMsR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FDRjtBQTFORCw4REEwTkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgdHlwZSB7IENsb3VkV2F0Y2hMb2dFdmVudCB9IGZyb20gJy4uLy4uLy4uLy4uL0Bhd3MtY2RrL3RtcC10b29sa2l0LWhlbHBlcnMvc3JjL2FwaS9pbyc7XG5pbXBvcnQgeyBJTywgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIHRyYWNraW5nIGluZm9ybWF0aW9uIG9uIHRoZSBsb2cgZ3JvdXBzIHRoYXQgYXJlXG4gKiBiZWluZyBtb25pdG9yZWRcbiAqL1xuaW50ZXJmYWNlIExvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzIHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnQgKGFjY291bnQvcmVnaW9uKVxuICAgKi9cbiAgcmVhZG9ubHkgc2RrOiBTREs7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIGxvZyBncm91cHMgYW5kIGFzc29jaWF0ZWQgc3RhcnRUaW1lIGluIGEgZ2l2ZW4gYWNjb3VudC5cbiAgICpcbiAgICogVGhlIG1vbml0b3Igd2lsbCByZWFkIGV2ZW50cyBmcm9tIHRoZSBsb2cgZ3JvdXAgc3RhcnRpbmcgYXQgdGhlXG4gICAqIGFzc29jaWF0ZWQgc3RhcnRUaW1lXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cHNTdGFydFRpbWVzOiB7IFtsb2dHcm91cE5hbWU6IHN0cmluZ106IG51bWJlciB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3JQcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgSW9Ib3N0IHVzZWQgZm9yIG1lc3NhZ2luZ1xuICAgKi9cbiAgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBmcm9tIHdoaWNoIHdlIHN0YXJ0IHJlYWRpbmcgbG9nIG1lc3NhZ2VzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm93XG4gICAqL1xuICByZWFkb25seSBzdGFydFRpbWU/OiBEYXRlO1xufVxuXG5leHBvcnQgY2xhc3MgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBub3QgdG8gZGlzcGxheVxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlcjtcblxuICAvKipcbiAgICogTWFwIG9mIGVudmlyb25tZW50IChhY2NvdW50OnJlZ2lvbikgdG8gTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3NcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIExvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzPigpO1xuXG4gIC8qKlxuICAgKiBBZnRlciByZWFkaW5nIGV2ZW50cyBmcm9tIGFsbCBDbG91ZFdhdGNoIGxvZyBncm91cHNcbiAgICogaG93IGxvbmcgc2hvdWxkIHdlIHdhaXQgdG8gcmVhZCBtb3JlIGV2ZW50cy5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgc29tZSBlcnJvciB3aXRoIHJlYWRpbmcgZXZlbnRzIChpLmUuIFRocm90dGxlKVxuICAgKiB0aGVuIHRoaXMgaXMgYWxzbyBob3cgbG9uZyB3ZSB3YWl0IHVudGlsIHdlIHRyeSBhZ2FpblxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBwb2xsaW5nSW50ZXJ2YWw6IG51bWJlciA9IDJfMDAwO1xuXG4gIHB1YmxpYyBtb25pdG9ySWQ/OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgaW9IZWxwZXI6IElvSGVscGVyO1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yUHJvcHMpIHtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHByb3BzLnN0YXJ0VGltZT8uZ2V0VGltZSgpID8/IERhdGUubm93KCk7XG4gICAgdGhpcy5pb0hlbHBlciA9IHByb3BzLmlvSGVscGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc3VtZSByZWFkaW5nL3ByaW50aW5nIGV2ZW50c1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGFjdGl2YXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubW9uaXRvcklkID0gdXVpZC52NCgpO1xuXG4gICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfSTUwMzIubXNnKCdTdGFydCBtb25pdG9yaW5nIGxvZyBncm91cHMnLCB7XG4gICAgICBtb25pdG9yOiB0aGlzLm1vbml0b3JJZCxcbiAgICAgIGxvZ0dyb3VwTmFtZXM6IHRoaXMubG9nR3JvdXBOYW1lcygpLFxuICAgIH0pKTtcblxuICAgIGF3YWl0IHRoaXMudGljaygpO1xuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlYWN0aXZhdGVzIHRoZSBtb25pdG9yIHNvIG5vIG5ldyBldmVudHMgYXJlIHJlYWRcbiAgICogdXNlIGNhc2UgZm9yIHRoaXMgaXMgd2hlbiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBwZXJmb3JtaW5nIGEgZGVwbG95bWVudFxuICAgKiBhbmQgZG9uJ3Qgd2FudCB0byBpbnRlcndlYXZlIGFsbCB0aGUgbG9ncyB0b2dldGhlciB3aXRoIHRoZSBDRk5cbiAgICogZGVwbG95bWVudCBsb2dzXG4gICAqXG4gICAqIEFsc28gcmVzZXRzIHRoZSBzdGFydCB0aW1lIHRvIGJlIHdoZW4gdGhlIG5ldyBkZXBsb3ltZW50IHdhcyB0cmlnZ2VyZWRcbiAgICogYW5kIGNsZWFycyB0aGUgbGlzdCBvZiB0cmFja2VkIGxvZyBncm91cHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZWFjdGl2YXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG9sZE1vbml0b3JJZCA9IHRoaXMubW9uaXRvcklkITtcbiAgICB0aGlzLm1vbml0b3JJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5DREtfVE9PTEtJVF9JNTAzNC5tc2coJ1N0b3BwZWQgbW9uaXRvcmluZyBsb2cgZ3JvdXBzJywge1xuICAgICAgbW9uaXRvcjogb2xkTW9uaXRvcklkLFxuICAgICAgbG9nR3JvdXBOYW1lczogdGhpcy5sb2dHcm91cE5hbWVzKCksXG4gICAgfSkpO1xuXG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyB0byByZWFkIGxvZyBldmVudHMgZnJvbS5cbiAgICogU2luY2Ugd2UgY291bGQgYmUgd2F0Y2hpbmcgbXVsdGlwbGUgc3RhY2tzIHRoYXQgZGVwbG95IHRvXG4gICAqIG11bHRpcGxlIGVudmlyb25tZW50cyAoYWNjb3VudCtyZWdpb24pLCB3ZSBuZWVkIHRvIHN0b3JlIGEgbGlzdCBvZiBsb2cgZ3JvdXBzXG4gICAqIHBlciBlbnYgYWxvbmcgd2l0aCB0aGUgU0RLIG9iamVjdCB0aGF0IGhhcyBhY2Nlc3MgdG8gcmVhZCBmcm9tXG4gICAqIHRoYXQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBwdWJsaWMgYWRkTG9nR3JvdXBzKGVudjogY3hhcGkuRW52aXJvbm1lbnQsIHNkazogU0RLLCBsb2dHcm91cE5hbWVzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGNvbnN0IGF3c0VudiA9IGAke2Vudi5hY2NvdW50fToke2Vudi5yZWdpb259YDtcbiAgICBjb25zdCBsb2dHcm91cHNTdGFydFRpbWVzID0gbG9nR3JvdXBOYW1lcy5yZWR1Y2UoXG4gICAgICAoYWNjLCBncm91cE5hbWUpID0+IHtcbiAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyB7IFtsb2dHcm91cE5hbWU6IHN0cmluZ106IG51bWJlciB9LFxuICAgICk7XG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3Muc2V0KGF3c0Vudiwge1xuICAgICAgc2RrLFxuICAgICAgbG9nR3JvdXBzU3RhcnRUaW1lczoge1xuICAgICAgICAuLi50aGlzLmVudnNMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5nZXQoYXdzRW52KT8ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgICAgLi4ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGxvZ0dyb3VwTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnZhbHVlcygpKS5mbGF0TWFwKChzZXR0aW5ncykgPT4gT2JqZWN0LmtleXMoc2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZU5leHRUaWNrKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5tb25pdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHZvaWQgdGhpcy50aWNrKCksIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdGljaygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBleGNsdWRpbmcgZnJvbSBjb2RlY292ZXJhZ2UgYmVjYXVzZSB0aGlzXG4gICAgLy8gZG9lc24ndCBhbHdheXMgcnVuIChkZXBlbmRzIG9uIHRpbWluZylcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghdGhpcy5tb25pdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRzID0gZmxhdHRlbihhd2FpdCB0aGlzLnJlYWROZXdFdmVudHMoKSk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICBhd2FpdCB0aGlzLnByaW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgbWlnaHQgaGF2ZSBiZWVuIHN0b3AoKXBlZCB3aGlsZSB0aGUgbmV0d29yayBjYWxsIHdhcyBpbiBwcm9ncmVzcy5cbiAgICAgIGlmICghdGhpcy5tb25pdG9ySWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTUwMzUubXNnKCdFcnJvciBvY2N1cnJlZCB3aGlsZSBtb25pdG9yaW5nIGxvZ3M6ICVzJywgeyBlcnJvcjogZSB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5zY2hlZHVsZU5leHRUaWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYWxsIG5ldyBsb2cgZXZlbnRzIGZyb20gYSBzZXQgb2YgQ2xvdWRXYXRjaCBMb2cgR3JvdXBzXG4gICAqIGluIHBhcmFsbGVsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlYWROZXdFdmVudHMoKTogUHJvbWlzZTxBcnJheTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4ge1xuICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+PiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2V0dGluZ3Mgb2YgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lcykpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlYWRFdmVudHNGcm9tTG9nR3JvdXAoc2V0dGluZ3MsIGdyb3VwKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpbWl0ZWQgc2V0IG9mIGxvZyBncm91cHNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW50IG91dCBhIGNsb3Vkd2F0Y2ggZXZlbnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcHJpbnQoZXZlbnQ6IENsb3VkV2F0Y2hMb2dFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0k1MDMzLm1zZyhcbiAgICAgIHV0aWwuZm9ybWF0KFxuICAgICAgICAnWyVzXSAlcyAlcycsXG4gICAgICAgIGNoYWxrLmJsdWUoZXZlbnQubG9nR3JvdXBOYW1lKSxcbiAgICAgICAgY2hhbGsueWVsbG93KGV2ZW50LnRpbWVzdGFtcC50b0xvY2FsZVRpbWVTdHJpbmcoKSksXG4gICAgICAgIGV2ZW50Lm1lc3NhZ2UudHJpbSgpLFxuICAgICAgKSxcbiAgICAgIGV2ZW50LFxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgQ2xvdWRXYXRjaCBMb2cgR3JvdXBcbiAgICogc3RhcnRpbmcgYXQgZWl0aGVyIHRoZSB0aW1lIHRoZSBob3Rzd2FwIHdhcyB0cmlnZ2VyZWQgb3JcbiAgICogd2hlbiB0aGUgbGFzdCBldmVudCB3YXMgcmVhZCBvbiB0aGUgcHJldmlvdXMgdGlja1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWFkRXZlbnRzRnJvbUxvZ0dyb3VwKFxuICAgIGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzOiBMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncyxcbiAgICBsb2dHcm91cE5hbWU6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+PiB7XG4gICAgY29uc3QgZXZlbnRzOiBDbG91ZFdhdGNoTG9nRXZlbnRbXSA9IFtdO1xuXG4gICAgLy8gbG9nIGV2ZW50cyBmcm9tIHNvbWUgc2VydmljZSBhcmUgaW5nZXN0ZWQgZmFzdGVyIHRoYW4gb3RoZXJzXG4gICAgLy8gc28gd2UgbmVlZCB0byB0cmFjayB0aGUgc3RhcnQvZW5kIHRpbWUgZm9yIGVhY2ggbG9nIGdyb3VwIGluZGl2aWR1YWxseVxuICAgIC8vIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHByb2Nlc3MgYWxsIGV2ZW50cyBmcm9tIGVhY2ggbG9nIGdyb3VwXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lc1tsb2dHcm91cE5hbWVdID8/IHRoaXMuc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnNkay5jbG91ZFdhdGNoTG9ncygpLmZpbHRlckxvZ0V2ZW50cyh7XG4gICAgICAgIGxvZ0dyb3VwTmFtZTogbG9nR3JvdXBOYW1lLFxuICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgZmlsdGVyZWRFdmVudHMgPSByZXNwb25zZS5ldmVudHMgPz8gW107XG5cbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZmlsdGVyZWRFdmVudHMpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UpIHtcbiAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLFxuICAgICAgICAgICAgbG9nR3JvdXBOYW1lLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBldmVudC50aW1lc3RhbXAgPyBuZXcgRGF0ZShldmVudC50aW1lc3RhbXApIDogbmV3IERhdGUoKSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChldmVudC50aW1lc3RhbXAgJiYgZW5kVGltZSA8IGV2ZW50LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgZW5kVGltZSA9IGV2ZW50LnRpbWVzdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFzIGxvbmcgYXMgdGhlcmUgYXJlIF9hbnlfIGV2ZW50cyBpbiB0aGUgbG9nIGdyb3VwIGBmaWx0ZXJMb2dFdmVudHNgIHdpbGwgcmV0dXJuIGEgbmV4dFRva2VuLlxuICAgICAgLy8gVGhpcyBpcyB0cnVlIGV2ZW4gaWYgdGhlc2UgZXZlbnRzIGFyZSBiZWZvcmUgYHN0YXJ0VGltZWAuIFNvIGlmIHdlIGhhdmUgMTAwIGV2ZW50cyBhbmQgYSBuZXh0VG9rZW5cbiAgICAgIC8vIHRoZW4gYXNzdW1lIHRoYXQgd2UgaGF2ZSBoaXQgdGhlIGxpbWl0IGFuZCBsZXQgdGhlIHVzZXIga25vdyBzb21lIG1lc3NhZ2VzIGhhdmUgYmVlbiBzdXBwcmVzc2VkLlxuICAgICAgLy8gV2UgYXJlIGVzc2VudGlhbGx5IHNob3dpbmcgdGhlbSBhIHNhbXBsaW5nICgxMDAwMCBldmVudHMgcHJpbnRlZCBvdXQgaXMgbm90IHZlcnkgdXNlZnVsKVxuICAgICAgaWYgKGZpbHRlcmVkRXZlbnRzLmxlbmd0aCA9PT0gMTAwICYmIHJlc3BvbnNlLm5leHRUb2tlbikge1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgbWVzc2FnZTogJz4+PiBgd2F0Y2hgIHNob3dzIG9ubHkgdGhlIGZpcnN0IDEwMCBsb2cgbWVzc2FnZXMgLSB0aGUgcmVzdCBoYXZlIGJlZW4gdHJ1bmNhdGVkLi4uJyxcbiAgICAgICAgICBsb2dHcm91cE5hbWUsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShlbmRUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAvLyB3aXRoIExhbWJkYSBmdW5jdGlvbnMgdGhlIENsb3VkV2F0Y2ggaXMgbm90IGNyZWF0ZWRcbiAgICAgIC8vIHVudGlsIHNvbWV0aGluZyBpcyBsb2dnZWQsIHNvIGp1c3Qga2VlcCBwb2xsaW5nIHVudGlsXG4gICAgICAvLyB0aGVyZSBpcyBzb210aGluZyB0byBmaW5kXG4gICAgICBpZiAoZS5uYW1lID09PSAnUmVzb3VyY2VOb3RGb3VuZEV4Y2VwdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgbG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lc1tsb2dHcm91cE5hbWVdID0gZW5kVGltZSArIDE7XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfVxufVxuIl19