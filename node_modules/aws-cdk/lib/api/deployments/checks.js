"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineAllowCrossAccountAssetPublishing = determineAllowCrossAccountAssetPublishing;
exports.getBootstrapStackInfo = getBootstrapStackInfo;
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
async function determineAllowCrossAccountAssetPublishing(sdk, ioHelper, customStackName) {
    try {
        const stackName = customStackName || 'CDKToolkit';
        const stackInfo = await getBootstrapStackInfo(sdk, stackName);
        if (!stackInfo.hasStagingBucket) {
            // indicates an intentional cross account setup
            return true;
        }
        if (stackInfo.bootstrapVersion >= 21) {
            // bootstrap stack version 21 contains a fix that will prevent cross
            // account publishing on the IAM level
            // https://github.com/aws/aws-cdk/pull/30823
            return true;
        }
        // If there is a staging bucket AND the bootstrap version is old, then we want to protect
        // against accidental cross-account publishing.
        return false;
    }
    catch (e) {
        // You would think we would need to fail closed here, but the reality is
        // that we get here if we couldn't find the bootstrap stack: that is
        // completely valid, and many large organizations may have their own method
        // of creating bootstrap resources. If they do, there's nothing for us to validate,
        // but we can't use that as a reason to disallow cross-account publishing. We'll just
        // have to trust they did their due diligence. So we fail open.
        await ioHelper.notify((0, messages_1.debug)(`Error determining cross account asset publishing: ${e}`));
        await ioHelper.notify((0, messages_1.debug)('Defaulting to allowing cross account asset publishing'));
        return true;
    }
}
async function getBootstrapStackInfo(sdk, stackName) {
    var _a, _b, _c;
    try {
        const cfn = sdk.cloudFormation();
        const stackResponse = await cfn.describeStacks({ StackName: stackName });
        if (!stackResponse.Stacks || stackResponse.Stacks.length === 0) {
            throw new error_1.ToolkitError(`Toolkit stack ${stackName} not found`);
        }
        const stack = stackResponse.Stacks[0];
        const versionOutput = (_a = stack.Outputs) === null || _a === void 0 ? void 0 : _a.find(output => output.OutputKey === 'BootstrapVersion');
        if (!(versionOutput === null || versionOutput === void 0 ? void 0 : versionOutput.OutputValue)) {
            throw new error_1.ToolkitError(`Unable to find BootstrapVersion output in the toolkit stack ${stackName}`);
        }
        const bootstrapVersion = parseInt(versionOutput.OutputValue);
        if (isNaN(bootstrapVersion)) {
            throw new error_1.ToolkitError(`Invalid BootstrapVersion value: ${versionOutput.OutputValue}`);
        }
        // try to get bucketname from the logical resource id. If there is no
        // bucketname, or the value doesn't look like an S3 bucket name, we assume
        // the bucket doesn't exist (this is for the case where a template customizer did
        // not dare to remove the Output, but put a dummy value there like '' or '-' or '***').
        //
        // We would have preferred to look at the stack resources here, but
        // unfortunately the deploy role doesn't have permissions call DescribeStackResources.
        const bucketName = (_c = (_b = stack.Outputs) === null || _b === void 0 ? void 0 : _b.find(output => output.OutputKey === 'BucketName')) === null || _c === void 0 ? void 0 : _c.OutputValue;
        // Must begin and end with letter or number.
        const hasStagingBucket = !!(bucketName && bucketName.match(/^[a-z0-9]/) && bucketName.match(/[a-z0-9]$/));
        return {
            hasStagingBucket,
            bootstrapVersion,
        };
    }
    catch (e) {
        throw new error_1.ToolkitError(`Error retrieving toolkit stack info: ${e}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY2hlY2tzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBS0EsOEZBbUNDO0FBT0Qsc0RBdUNDO0FBckZELGlEQUEyQztBQUMzQywrQ0FBbUQ7QUFHNUMsS0FBSyxVQUFVLHlDQUF5QyxDQUM3RCxHQUFRLEVBQ1IsUUFBa0IsRUFDbEIsZUFBd0I7SUFFeEIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxTQUFTLEdBQUcsZUFBZSxJQUFJLFlBQVksQ0FBQztRQUNsRCxNQUFNLFNBQVMsR0FBRyxNQUFNLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUU5RCxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDaEMsK0NBQStDO1lBQy9DLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELElBQUksU0FBUyxDQUFDLGdCQUFnQixJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ3JDLG9FQUFvRTtZQUNwRSxzQ0FBc0M7WUFDdEMsNENBQTRDO1lBQzVDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELHlGQUF5RjtRQUN6RiwrQ0FBK0M7UUFDL0MsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLHdFQUF3RTtRQUN4RSxvRUFBb0U7UUFDcEUsMkVBQTJFO1FBQzNFLG1GQUFtRjtRQUNuRixxRkFBcUY7UUFDckYsK0RBQStEO1FBQy9ELE1BQU0sUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFBLGdCQUFLLEVBQUMscURBQXFELENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2RixNQUFNLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBQSxnQkFBSyxFQUFDLHVEQUF1RCxDQUFDLENBQUMsQ0FBQztRQUN0RixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7QUFDSCxDQUFDO0FBT00sS0FBSyxVQUFVLHFCQUFxQixDQUFDLEdBQVEsRUFBRSxTQUFpQjs7SUFDckUsSUFBSSxDQUFDO1FBQ0gsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sYUFBYSxHQUFHLE1BQU0sR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBRXpFLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQy9ELE1BQU0sSUFBSSxvQkFBWSxDQUFDLGlCQUFpQixTQUFTLFlBQVksQ0FBQyxDQUFDO1FBQ2pFLENBQUM7UUFFRCxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sYUFBYSxHQUFHLE1BQUEsS0FBSyxDQUFDLE9BQU8sMENBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsS0FBSyxrQkFBa0IsQ0FBQyxDQUFDO1FBRTdGLElBQUksQ0FBQyxDQUFBLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxXQUFXLENBQUEsRUFBRSxDQUFDO1lBQ2hDLE1BQU0sSUFBSSxvQkFBWSxDQUFDLCtEQUErRCxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBQ3JHLENBQUM7UUFFRCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDN0QsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO1lBQzVCLE1BQU0sSUFBSSxvQkFBWSxDQUFDLG1DQUFtQyxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUN6RixDQUFDO1FBRUQscUVBQXFFO1FBQ3JFLDBFQUEwRTtRQUMxRSxpRkFBaUY7UUFDakYsdUZBQXVGO1FBQ3ZGLEVBQUU7UUFDRixtRUFBbUU7UUFDbkUsc0ZBQXNGO1FBQ3RGLE1BQU0sVUFBVSxHQUFHLE1BQUEsTUFBQSxLQUFLLENBQUMsT0FBTywwQ0FBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsU0FBUyxLQUFLLFlBQVksQ0FBQywwQ0FBRSxXQUFXLENBQUM7UUFDakcsNENBQTRDO1FBQzVDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBRTFHLE9BQU87WUFDTCxnQkFBZ0I7WUFDaEIsZ0JBQWdCO1NBQ2pCLENBQUM7SUFDSixDQUFDO0lBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztRQUNYLE1BQU0sSUFBSSxvQkFBWSxDQUFDLHdDQUF3QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2NsaS9tZXNzYWdlcyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IFNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZUFsbG93Q3Jvc3NBY2NvdW50QXNzZXRQdWJsaXNoaW5nKFxuICBzZGs6IFNESyxcbiAgaW9IZWxwZXI6IElvSGVscGVyLFxuICBjdXN0b21TdGFja05hbWU/OiBzdHJpbmcsXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGFja05hbWUgPSBjdXN0b21TdGFja05hbWUgfHwgJ0NES1Rvb2xraXQnO1xuICAgIGNvbnN0IHN0YWNrSW5mbyA9IGF3YWl0IGdldEJvb3RzdHJhcFN0YWNrSW5mbyhzZGssIHN0YWNrTmFtZSk7XG5cbiAgICBpZiAoIXN0YWNrSW5mby5oYXNTdGFnaW5nQnVja2V0KSB7XG4gICAgICAvLyBpbmRpY2F0ZXMgYW4gaW50ZW50aW9uYWwgY3Jvc3MgYWNjb3VudCBzZXR1cFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrSW5mby5ib290c3RyYXBWZXJzaW9uID49IDIxKSB7XG4gICAgICAvLyBib290c3RyYXAgc3RhY2sgdmVyc2lvbiAyMSBjb250YWlucyBhIGZpeCB0aGF0IHdpbGwgcHJldmVudCBjcm9zc1xuICAgICAgLy8gYWNjb3VudCBwdWJsaXNoaW5nIG9uIHRoZSBJQU0gbGV2ZWxcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9wdWxsLzMwODIzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHN0YWdpbmcgYnVja2V0IEFORCB0aGUgYm9vdHN0cmFwIHZlcnNpb24gaXMgb2xkLCB0aGVuIHdlIHdhbnQgdG8gcHJvdGVjdFxuICAgIC8vIGFnYWluc3QgYWNjaWRlbnRhbCBjcm9zcy1hY2NvdW50IHB1Ymxpc2hpbmcuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gWW91IHdvdWxkIHRoaW5rIHdlIHdvdWxkIG5lZWQgdG8gZmFpbCBjbG9zZWQgaGVyZSwgYnV0IHRoZSByZWFsaXR5IGlzXG4gICAgLy8gdGhhdCB3ZSBnZXQgaGVyZSBpZiB3ZSBjb3VsZG4ndCBmaW5kIHRoZSBib290c3RyYXAgc3RhY2s6IHRoYXQgaXNcbiAgICAvLyBjb21wbGV0ZWx5IHZhbGlkLCBhbmQgbWFueSBsYXJnZSBvcmdhbml6YXRpb25zIG1heSBoYXZlIHRoZWlyIG93biBtZXRob2RcbiAgICAvLyBvZiBjcmVhdGluZyBib290c3RyYXAgcmVzb3VyY2VzLiBJZiB0aGV5IGRvLCB0aGVyZSdzIG5vdGhpbmcgZm9yIHVzIHRvIHZhbGlkYXRlLFxuICAgIC8vIGJ1dCB3ZSBjYW4ndCB1c2UgdGhhdCBhcyBhIHJlYXNvbiB0byBkaXNhbGxvdyBjcm9zcy1hY2NvdW50IHB1Ymxpc2hpbmcuIFdlJ2xsIGp1c3RcbiAgICAvLyBoYXZlIHRvIHRydXN0IHRoZXkgZGlkIHRoZWlyIGR1ZSBkaWxpZ2VuY2UuIFNvIHdlIGZhaWwgb3Blbi5cbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoZGVidWcoYEVycm9yIGRldGVybWluaW5nIGNyb3NzIGFjY291bnQgYXNzZXQgcHVibGlzaGluZzogJHtlfWApKTtcbiAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoZGVidWcoJ0RlZmF1bHRpbmcgdG8gYWxsb3dpbmcgY3Jvc3MgYWNjb3VudCBhc3NldCBwdWJsaXNoaW5nJykpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmludGVyZmFjZSBCb290c3RyYXBTdGFja0luZm8ge1xuICBoYXNTdGFnaW5nQnVja2V0OiBib29sZWFuO1xuICBib290c3RyYXBWZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCb290c3RyYXBTdGFja0luZm8oc2RrOiBTREssIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCb290c3RyYXBTdGFja0luZm8+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjZm4gPSBzZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBzdGFja1Jlc3BvbnNlID0gYXdhaXQgY2ZuLmRlc2NyaWJlU3RhY2tzKHsgU3RhY2tOYW1lOiBzdGFja05hbWUgfSk7XG5cbiAgICBpZiAoIXN0YWNrUmVzcG9uc2UuU3RhY2tzIHx8IHN0YWNrUmVzcG9uc2UuU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVG9vbGtpdCBzdGFjayAke3N0YWNrTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja1Jlc3BvbnNlLlN0YWNrc1swXTtcbiAgICBjb25zdCB2ZXJzaW9uT3V0cHV0ID0gc3RhY2suT3V0cHV0cz8uZmluZChvdXRwdXQgPT4gb3V0cHV0Lk91dHB1dEtleSA9PT0gJ0Jvb3RzdHJhcFZlcnNpb24nKTtcblxuICAgIGlmICghdmVyc2lvbk91dHB1dD8uT3V0cHV0VmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuYWJsZSB0byBmaW5kIEJvb3RzdHJhcFZlcnNpb24gb3V0cHV0IGluIHRoZSB0b29sa2l0IHN0YWNrICR7c3RhY2tOYW1lfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGJvb3RzdHJhcFZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uT3V0cHV0Lk91dHB1dFZhbHVlKTtcbiAgICBpZiAoaXNOYU4oYm9vdHN0cmFwVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYEludmFsaWQgQm9vdHN0cmFwVmVyc2lvbiB2YWx1ZTogJHt2ZXJzaW9uT3V0cHV0Lk91dHB1dFZhbHVlfWApO1xuICAgIH1cblxuICAgIC8vIHRyeSB0byBnZXQgYnVja2V0bmFtZSBmcm9tIHRoZSBsb2dpY2FsIHJlc291cmNlIGlkLiBJZiB0aGVyZSBpcyBub1xuICAgIC8vIGJ1Y2tldG5hbWUsIG9yIHRoZSB2YWx1ZSBkb2Vzbid0IGxvb2sgbGlrZSBhbiBTMyBidWNrZXQgbmFtZSwgd2UgYXNzdW1lXG4gICAgLy8gdGhlIGJ1Y2tldCBkb2Vzbid0IGV4aXN0ICh0aGlzIGlzIGZvciB0aGUgY2FzZSB3aGVyZSBhIHRlbXBsYXRlIGN1c3RvbWl6ZXIgZGlkXG4gICAgLy8gbm90IGRhcmUgdG8gcmVtb3ZlIHRoZSBPdXRwdXQsIGJ1dCBwdXQgYSBkdW1teSB2YWx1ZSB0aGVyZSBsaWtlICcnIG9yICctJyBvciAnKioqJykuXG4gICAgLy9cbiAgICAvLyBXZSB3b3VsZCBoYXZlIHByZWZlcnJlZCB0byBsb29rIGF0IHRoZSBzdGFjayByZXNvdXJjZXMgaGVyZSwgYnV0XG4gICAgLy8gdW5mb3J0dW5hdGVseSB0aGUgZGVwbG95IHJvbGUgZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIGNhbGwgRGVzY3JpYmVTdGFja1Jlc291cmNlcy5cbiAgICBjb25zdCBidWNrZXROYW1lID0gc3RhY2suT3V0cHV0cz8uZmluZChvdXRwdXQgPT4gb3V0cHV0Lk91dHB1dEtleSA9PT0gJ0J1Y2tldE5hbWUnKT8uT3V0cHV0VmFsdWU7XG4gICAgLy8gTXVzdCBiZWdpbiBhbmQgZW5kIHdpdGggbGV0dGVyIG9yIG51bWJlci5cbiAgICBjb25zdCBoYXNTdGFnaW5nQnVja2V0ID0gISEoYnVja2V0TmFtZSAmJiBidWNrZXROYW1lLm1hdGNoKC9eW2EtejAtOV0vKSAmJiBidWNrZXROYW1lLm1hdGNoKC9bYS16MC05XSQvKSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGFzU3RhZ2luZ0J1Y2tldCxcbiAgICAgIGJvb3RzdHJhcFZlcnNpb24sXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYEVycm9yIHJldHJpZXZpbmcgdG9vbGtpdCBzdGFjayBpbmZvOiAke2V9YCk7XG4gIH1cbn1cbiJdfQ==