"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMetadataAssetsToManifest = addMetadataAssetsToManifest;
// eslint-disable-next-line max-len
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
/**
 * Take the metadata assets from the given stack and add them to the given asset manifest
 *
 * Returns the CloudFormation parameters that need to be sent to the template to
 * pass Asset coordinates.
 */
async function addMetadataAssetsToManifest(ioHelper, stack, assetManifest, envResources, reuse) {
    reuse = reuse || [];
    const assets = stack.assets;
    if (assets.length === 0) {
        return {};
    }
    const toolkitInfo = await envResources.lookupToolkit();
    if (!toolkitInfo.found) {
        // eslint-disable-next-line max-len
        throw new error_1.ToolkitError(`This stack uses assets, so the toolkit stack must be deployed to the environment (Run "${chalk.blue('cdk bootstrap ' + stack.environment.name)}")`);
    }
    const params = {};
    for (const asset of assets) {
        // FIXME: Should have excluded by construct path here instead of by unique ID, preferably using
        // minimatch so we can support globs. Maybe take up during artifact refactoring.
        const reuseAsset = reuse.indexOf(asset.id) > -1;
        if (reuseAsset) {
            await ioHelper.notify((0, messages_1.debug)(`Reusing asset ${asset.id}: ${JSON.stringify(asset)}`));
            continue;
        }
        await ioHelper.notify((0, messages_1.debug)(`Preparing asset ${asset.id}: ${JSON.stringify(asset)}`));
        if (!stack.assembly) {
            throw new error_1.ToolkitError('Unexpected: stack assembly is required in order to find assets in assembly directory');
        }
        Object.assign(params, await prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo));
    }
    return params;
}
// eslint-disable-next-line max-len
async function prepareAsset(ioHelper, asset, assetManifest, envResources, toolkitInfo) {
    switch (asset.packaging) {
        case 'zip':
        case 'file':
            return prepareFileAsset(ioHelper, asset, assetManifest, toolkitInfo, asset.packaging === 'zip' ? cxschema.FileAssetPackaging.ZIP_DIRECTORY : cxschema.FileAssetPackaging.FILE);
        case 'container-image':
            return prepareDockerImageAsset(asset, assetManifest, envResources);
        default:
            // eslint-disable-next-line max-len
            throw new error_1.ToolkitError(`Unsupported packaging type: ${asset.packaging}. You might need to upgrade your aws-cdk toolkit to support this asset type.`);
    }
}
async function prepareFileAsset(ioHelper, asset, assetManifest, toolkitInfo, packaging) {
    const extension = packaging === cxschema.FileAssetPackaging.ZIP_DIRECTORY ? '.zip' : path.extname(asset.path);
    const baseName = `${asset.sourceHash}${extension}`;
    // Simplify key: assets/abcdef/abcdef.zip is kinda silly and unnecessary, so if they're the same just pick one component.
    const s3Prefix = asset.id === asset.sourceHash ? 'assets/' : `assets/${asset.id}/`;
    const key = `${s3Prefix}${baseName}`;
    const s3url = `s3://${toolkitInfo.bucketName}/${key}`;
    await ioHelper.notify((0, messages_1.debug)(`Storing asset ${asset.path} at ${s3url}`));
    assetManifest.addFileAsset(asset.sourceHash, {
        path: asset.path,
        packaging,
    }, {
        bucketName: toolkitInfo.bucketName,
        objectKey: key,
    });
    return {
        [asset.s3BucketParameter]: toolkitInfo.bucketName,
        [asset.s3KeyParameter]: `${s3Prefix}${cxapi.ASSET_PREFIX_SEPARATOR}${baseName}`,
        [asset.artifactHashParameter]: asset.sourceHash,
    };
}
async function prepareDockerImageAsset(asset, assetManifest, envResources) {
    var _a, _b;
    // Pre-1.21.0, repositoryName can be specified by the user or can be left out, in which case we make
    // a per-asset repository which will get adopted and cleaned up along with the stack.
    // Post-1.21.0, repositoryName will always be specified and it will be a shared repository between
    // all assets, and asset will have imageTag specified as well. Validate the combination.
    if (!asset.imageNameParameter && (!asset.repositoryName || !asset.imageTag)) {
        throw new error_1.ToolkitError('Invalid Docker image asset configuration: "repositoryName" and "imageTag" are required when "imageNameParameter" is left out');
    }
    const repositoryName = (_a = asset.repositoryName) !== null && _a !== void 0 ? _a : 'cdk/' + asset.id.replace(/[:/]/g, '-').toLowerCase();
    // Make sure the repository exists, since the 'cdk-assets' tool will not create it for us.
    const { repositoryUri } = await envResources.prepareEcrRepository(repositoryName);
    const imageTag = (_b = asset.imageTag) !== null && _b !== void 0 ? _b : asset.sourceHash;
    assetManifest.addDockerImageAsset(asset.sourceHash, {
        directory: asset.path,
        dockerBuildArgs: asset.buildArgs,
        dockerBuildSsh: asset.buildSsh,
        dockerBuildTarget: asset.target,
        dockerFile: asset.file,
        networkMode: asset.networkMode,
        platform: asset.platform,
        dockerOutputs: asset.outputs,
    }, {
        repositoryName,
        imageTag,
    });
    if (!asset.imageNameParameter) {
        return {};
    }
    return { [asset.imageNameParameter]: `${repositoryUri}:${imageTag}` };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXNzZXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBa0JBLGtFQXlDQztBQTNERCxtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLDJEQUEyRDtBQUMzRCx5Q0FBeUM7QUFDekMsK0JBQStCO0FBRy9CLGlEQUEyQztBQUMzQywrQ0FBbUQ7QUFJbkQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsMkJBQTJCLENBQy9DLFFBQWtCLEVBQ2xCLEtBQXdDLEVBQ3hDLGFBQW1DLEVBQ25DLFlBQWtDLEVBQ2xDLEtBQWdCO0lBRWhCLEtBQUssR0FBRyxLQUFLLElBQUksRUFBRSxDQUFDO0lBQ3BCLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7SUFFNUIsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sWUFBWSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZELElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDdkIsbUNBQW1DO1FBQ25DLE1BQU0sSUFBSSxvQkFBWSxDQUFDLDBGQUEwRixLQUFLLENBQUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxXQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQy9LLENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBMkIsRUFBRSxDQUFDO0lBRTFDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7UUFDM0IsK0ZBQStGO1FBQy9GLGdGQUFnRjtRQUNoRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVoRCxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsTUFBTSxRQUFRLENB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QUFjLEVBQUUsS0FBSyxDQUFDLFFBQVE7UUFDOUIsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLE1BQU07UUFDL0IsVUFBVSxFQUFFLEtBQUssQ0FBQyxJQUFJO1FBQ3RCLFdBQVcsRUFBRSxLQUFLLENBQUMsV0FBVztRQUM5QixRQUFRLEVBQUUsS0FBSyxDQUFDLFFBQVE7UUFDeEIsYUFBYSxFQUFFLEtBQUssQ0FBQyxPQUFPO0tBQzdCLEVBQUU7UUFDRCxjQUFjO1FBQ2QsUUFBUTtLQUNULENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM5QixPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFDRCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFBRSxHQUFHLGFBQWEsSUFBSSxRQUFRLEVBQUUsRUFBRSxDQUFDO0FBQ3hFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdEJ1aWxkZXIgfSBmcm9tICcuL2Fzc2V0LW1hbmlmZXN0LWJ1aWxkZXInO1xuaW1wb3J0IHsgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2NsaS9tZXNzYWdlcyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IEVudmlyb25tZW50UmVzb3VyY2VzIH0gZnJvbSAnLi4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgVG9vbGtpdEluZm8gfSBmcm9tICcuLi90b29sa2l0LWluZm8nO1xuXG4vKipcbiAqIFRha2UgdGhlIG1ldGFkYXRhIGFzc2V0cyBmcm9tIHRoZSBnaXZlbiBzdGFjayBhbmQgYWRkIHRoZW0gdG8gdGhlIGdpdmVuIGFzc2V0IG1hbmlmZXN0XG4gKlxuICogUmV0dXJucyB0aGUgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVycyB0aGF0IG5lZWQgdG8gYmUgc2VudCB0byB0aGUgdGVtcGxhdGUgdG9cbiAqIHBhc3MgQXNzZXQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRNZXRhZGF0YUFzc2V0c1RvTWFuaWZlc3QoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMsXG4gIHJldXNlPzogc3RyaW5nW10sXG4pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHN0cmluZz4+IHtcbiAgcmV1c2UgPSByZXVzZSB8fCBbXTtcbiAgY29uc3QgYXNzZXRzID0gc3RhY2suYXNzZXRzO1xuXG4gIGlmIChhc3NldHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgdG9vbGtpdEluZm8gPSBhd2FpdCBlbnZSZXNvdXJjZXMubG9va3VwVG9vbGtpdCgpO1xuICBpZiAoIXRvb2xraXRJbmZvLmZvdW5kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBUaGlzIHN0YWNrIHVzZXMgYXNzZXRzLCBzbyB0aGUgdG9vbGtpdCBzdGFjayBtdXN0IGJlIGRlcGxveWVkIHRvIHRoZSBlbnZpcm9ubWVudCAoUnVuIFwiJHtjaGFsay5ibHVlKCdjZGsgYm9vdHN0cmFwICcgKyBzdGFjay5lbnZpcm9ubWVudCEubmFtZSl9XCIpYCk7XG4gIH1cblxuICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICBmb3IgKGNvbnN0IGFzc2V0IG9mIGFzc2V0cykge1xuICAgIC8vIEZJWE1FOiBTaG91bGQgaGF2ZSBleGNsdWRlZCBieSBjb25zdHJ1Y3QgcGF0aCBoZXJlIGluc3RlYWQgb2YgYnkgdW5pcXVlIElELCBwcmVmZXJhYmx5IHVzaW5nXG4gICAgLy8gbWluaW1hdGNoIHNvIHdlIGNhbiBzdXBwb3J0IGdsb2JzLiBNYXliZSB0YWtlIHVwIGR1cmluZyBhcnRpZmFjdCByZWZhY3RvcmluZy5cbiAgICBjb25zdCByZXVzZUFzc2V0ID0gcmV1c2UuaW5kZXhPZihhc3NldC5pZCkgPiAtMTtcblxuICAgIGlmIChyZXVzZUFzc2V0KSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5ub3RpZnkoZGVidWcoYFJldXNpbmcgYXNzZXQgJHthc3NldC5pZH06ICR7SlNPTi5zdHJpbmdpZnkoYXNzZXQpfWApKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGF3YWl0IGlvSGVscGVyLm5vdGlmeShkZWJ1ZyhgUHJlcGFyaW5nIGFzc2V0ICR7YXNzZXQuaWR9OiAke0pTT04uc3RyaW5naWZ5KGFzc2V0KX1gKSk7XG4gICAgaWYgKCFzdGFjay5hc3NlbWJseSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVW5leHBlY3RlZDogc3RhY2sgYXNzZW1ibHkgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gZmluZCBhc3NldHMgaW4gYXNzZW1ibHkgZGlyZWN0b3J5Jyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGF3YWl0IHByZXBhcmVBc3NldChpb0hlbHBlciwgYXNzZXQsIGFzc2V0TWFuaWZlc3QsIGVudlJlc291cmNlcywgdG9vbGtpdEluZm8pKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlQXNzZXQoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgYXNzZXQ6IGN4c2NoZW1hLkFzc2V0TWV0YWRhdGFFbnRyeSxcbiAgYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdEJ1aWxkZXIsXG4gIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMsXG4gIHRvb2xraXRJbmZvOiBUb29sa2l0SW5mbyxcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4ge1xuICBzd2l0Y2ggKGFzc2V0LnBhY2thZ2luZykge1xuICAgIGNhc2UgJ3ppcCc6XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gcHJlcGFyZUZpbGVBc3NldChcbiAgICAgICAgaW9IZWxwZXIsXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhc3NldE1hbmlmZXN0LFxuICAgICAgICB0b29sa2l0SW5mbyxcbiAgICAgICAgYXNzZXQucGFja2FnaW5nID09PSAnemlwJyA/IGN4c2NoZW1hLkZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZIDogY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLkZJTEUpO1xuICAgIGNhc2UgJ2NvbnRhaW5lci1pbWFnZSc6XG4gICAgICByZXR1cm4gcHJlcGFyZURvY2tlckltYWdlQXNzZXQoYXNzZXQsIGFzc2V0TWFuaWZlc3QsIGVudlJlc291cmNlcyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbnN1cHBvcnRlZCBwYWNrYWdpbmcgdHlwZTogJHsoYXNzZXQgYXMgYW55KS5wYWNrYWdpbmd9LiBZb3UgbWlnaHQgbmVlZCB0byB1cGdyYWRlIHlvdXIgYXdzLWNkayB0b29sa2l0IHRvIHN1cHBvcnQgdGhpcyBhc3NldCB0eXBlLmApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVGaWxlQXNzZXQoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgYXNzZXQ6IGN4c2NoZW1hLkZpbGVBc3NldE1ldGFkYXRhRW50cnksXG4gIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLFxuICB0b29sa2l0SW5mbzogVG9vbGtpdEluZm8sXG4gIHBhY2thZ2luZzogY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLFxuKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIGNvbnN0IGV4dGVuc2lvbiA9IHBhY2thZ2luZyA9PT0gY3hzY2hlbWEuRmlsZUFzc2V0UGFja2FnaW5nLlpJUF9ESVJFQ1RPUlkgPyAnLnppcCcgOiBwYXRoLmV4dG5hbWUoYXNzZXQucGF0aCk7XG4gIGNvbnN0IGJhc2VOYW1lID0gYCR7YXNzZXQuc291cmNlSGFzaH0ke2V4dGVuc2lvbn1gO1xuICAvLyBTaW1wbGlmeSBrZXk6IGFzc2V0cy9hYmNkZWYvYWJjZGVmLnppcCBpcyBraW5kYSBzaWxseSBhbmQgdW5uZWNlc3NhcnksIHNvIGlmIHRoZXkncmUgdGhlIHNhbWUganVzdCBwaWNrIG9uZSBjb21wb25lbnQuXG4gIGNvbnN0IHMzUHJlZml4ID0gYXNzZXQuaWQgPT09IGFzc2V0LnNvdXJjZUhhc2ggPyAnYXNzZXRzLycgOiBgYXNzZXRzLyR7YXNzZXQuaWR9L2A7XG4gIGNvbnN0IGtleSA9IGAke3MzUHJlZml4fSR7YmFzZU5hbWV9YDtcbiAgY29uc3QgczN1cmwgPSBgczM6Ly8ke3Rvb2xraXRJbmZvLmJ1Y2tldE5hbWV9LyR7a2V5fWA7XG5cbiAgYXdhaXQgaW9IZWxwZXIubm90aWZ5KGRlYnVnKGBTdG9yaW5nIGFzc2V0ICR7YXNzZXQucGF0aH0gYXQgJHtzM3VybH1gKSk7XG5cbiAgYXNzZXRNYW5pZmVzdC5hZGRGaWxlQXNzZXQoYXNzZXQuc291cmNlSGFzaCwge1xuICAgIHBhdGg6IGFzc2V0LnBhdGgsXG4gICAgcGFja2FnaW5nLFxuICB9LCB7XG4gICAgYnVja2V0TmFtZTogdG9vbGtpdEluZm8uYnVja2V0TmFtZSxcbiAgICBvYmplY3RLZXk6IGtleSxcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBbYXNzZXQuczNCdWNrZXRQYXJhbWV0ZXJdOiB0b29sa2l0SW5mby5idWNrZXROYW1lLFxuICAgIFthc3NldC5zM0tleVBhcmFtZXRlcl06IGAke3MzUHJlZml4fSR7Y3hhcGkuQVNTRVRfUFJFRklYX1NFUEFSQVRPUn0ke2Jhc2VOYW1lfWAsXG4gICAgW2Fzc2V0LmFydGlmYWN0SGFzaFBhcmFtZXRlcl06IGFzc2V0LnNvdXJjZUhhc2gsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVEb2NrZXJJbWFnZUFzc2V0KFxuICBhc3NldDogY3hzY2hlbWEuQ29udGFpbmVySW1hZ2VBc3NldE1ldGFkYXRhRW50cnksXG4gIGFzc2V0TWFuaWZlc3Q6IEFzc2V0TWFuaWZlc3RCdWlsZGVyLFxuICBlbnZSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gIC8vIFByZS0xLjIxLjAsIHJlcG9zaXRvcnlOYW1lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgb3IgY2FuIGJlIGxlZnQgb3V0LCBpbiB3aGljaCBjYXNlIHdlIG1ha2VcbiAgLy8gYSBwZXItYXNzZXQgcmVwb3NpdG9yeSB3aGljaCB3aWxsIGdldCBhZG9wdGVkIGFuZCBjbGVhbmVkIHVwIGFsb25nIHdpdGggdGhlIHN0YWNrLlxuICAvLyBQb3N0LTEuMjEuMCwgcmVwb3NpdG9yeU5hbWUgd2lsbCBhbHdheXMgYmUgc3BlY2lmaWVkIGFuZCBpdCB3aWxsIGJlIGEgc2hhcmVkIHJlcG9zaXRvcnkgYmV0d2VlblxuICAvLyBhbGwgYXNzZXRzLCBhbmQgYXNzZXQgd2lsbCBoYXZlIGltYWdlVGFnIHNwZWNpZmllZCBhcyB3ZWxsLiBWYWxpZGF0ZSB0aGUgY29tYmluYXRpb24uXG4gIGlmICghYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyICYmICghYXNzZXQucmVwb3NpdG9yeU5hbWUgfHwgIWFzc2V0LmltYWdlVGFnKSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0ludmFsaWQgRG9ja2VyIGltYWdlIGFzc2V0IGNvbmZpZ3VyYXRpb246IFwicmVwb3NpdG9yeU5hbWVcIiBhbmQgXCJpbWFnZVRhZ1wiIGFyZSByZXF1aXJlZCB3aGVuIFwiaW1hZ2VOYW1lUGFyYW1ldGVyXCIgaXMgbGVmdCBvdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcG9zaXRvcnlOYW1lID0gYXNzZXQucmVwb3NpdG9yeU5hbWUgPz8gJ2Nkay8nICsgYXNzZXQuaWQucmVwbGFjZSgvWzovXS9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByZXBvc2l0b3J5IGV4aXN0cywgc2luY2UgdGhlICdjZGstYXNzZXRzJyB0b29sIHdpbGwgbm90IGNyZWF0ZSBpdCBmb3IgdXMuXG4gIGNvbnN0IHsgcmVwb3NpdG9yeVVyaSB9ID0gYXdhaXQgZW52UmVzb3VyY2VzLnByZXBhcmVFY3JSZXBvc2l0b3J5KHJlcG9zaXRvcnlOYW1lKTtcbiAgY29uc3QgaW1hZ2VUYWcgPSBhc3NldC5pbWFnZVRhZyA/PyBhc3NldC5zb3VyY2VIYXNoO1xuXG4gIGFzc2V0TWFuaWZlc3QuYWRkRG9ja2VySW1hZ2VBc3NldChhc3NldC5zb3VyY2VIYXNoLCB7XG4gICAgZGlyZWN0b3J5OiBhc3NldC5wYXRoLFxuICAgIGRvY2tlckJ1aWxkQXJnczogYXNzZXQuYnVpbGRBcmdzLFxuICAgIGRvY2tlckJ1aWxkU3NoOiBhc3NldC5idWlsZFNzaCxcbiAgICBkb2NrZXJCdWlsZFRhcmdldDogYXNzZXQudGFyZ2V0LFxuICAgIGRvY2tlckZpbGU6IGFzc2V0LmZpbGUsXG4gICAgbmV0d29ya01vZGU6IGFzc2V0Lm5ldHdvcmtNb2RlLFxuICAgIHBsYXRmb3JtOiBhc3NldC5wbGF0Zm9ybSxcbiAgICBkb2NrZXJPdXRwdXRzOiBhc3NldC5vdXRwdXRzLFxuICB9LCB7XG4gICAgcmVwb3NpdG9yeU5hbWUsXG4gICAgaW1hZ2VUYWcsXG4gIH0pO1xuXG4gIGlmICghYXNzZXQuaW1hZ2VOYW1lUGFyYW1ldGVyKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiB7IFthc3NldC5pbWFnZU5hbWVQYXJhbWV0ZXJdOiBgJHtyZXBvc2l0b3J5VXJpfToke2ltYWdlVGFnfWAgfTtcbn1cbiJdfQ==